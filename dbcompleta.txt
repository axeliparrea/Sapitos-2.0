-- ========================================
-- 1. ROGELIO'S SUPER COOL TABLES
-- ========================================
-- 1.1 Tabla de Roles
CREATE TABLE Rol2 (
Rol_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Nombre NVARCHAR(100) NOT NULL
);
-- 1.2 Tabla de Locations
CREATE TABLE Location2 (
Location_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Nombre NVARCHAR(100),
Tipo NVARCHAR(50),
PosicionX INTEGER,
PosicionY INTEGER,
FechaCreado DATE
);
-- 1.3 Tabla de Usuarios
CREATE TABLE Usuario2 (
Usuario_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Correo NVARCHAR(255),
Username NVARCHAR(100),
Nombre NVARCHAR(100) NOT NULL,
Rol_ID INTEGER,
Clave NVARCHAR(255) NOT NULL,
Location_ID INTEGER,
FechaEmpiezo DATE,
RFC NVARCHAR(13),
FOREIGN KEY (Rol_ID) REFERENCES Rol2(Rol_ID),
FOREIGN KEY (Location_ID) REFERENCES Location2(Location_ID)
);
-- 1.4 Tabla de Artículos
CREATE TABLE Articulo2 (
Articulo_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Nombre NVARCHAR(100) NOT NULL,
Categoria NVARCHAR(100),
PrecioProveedor DECIMAL(10,2),
PrecioVenta DECIMAL(10,2),
Temporada NVARCHAR(50)
);
-- 1.5 Tabla de Inventario
CREATE TABLE Inventario2 (
Inventario_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Articulo_ID INTEGER,
Location_ID INTEGER,
StockActual INTEGER,
Importacion INTEGER,
Exportacion INTEGER,
StockMinimo INTEGER,
StockRecomendado INTEGER,
FechaUltimaImportacion DATE,
FechaUltimaExportacion DATE,
MargenGanancia DECIMAL(5,2),
TiempoReposicion DECIMAL(5,2),
StockSeguridad INTEGER,
DemandaPromedio DECIMAL(5,2),
FOREIGN KEY (Articulo_ID) REFERENCES Articulo2(Articulo_ID),
FOREIGN KEY (Location_ID) REFERENCES Location2(Location_ID)
);
-- 1.6 Tabla de Fabricación
CREATE TABLE Fabricacion2 (
Fabricacion_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Location_ID INTEGER,
Articulo_ID INTEGER,
FOREIGN KEY (Location_ID) REFERENCES Location2(Location_ID),
FOREIGN KEY (Articulo_ID) REFERENCES Articulo2(Articulo_ID)
);
-- 1.7 Tabla de Métodos de Pago
CREATE TABLE MetodoPago2 (
MetodoPago_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Nombre NVARCHAR(100) NOT NULL
);
-- 1.8 Tabla de Órdenes
CREATE TABLE Ordenes2 (
Orden_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Creado_por_ID INTEGER,
Modificado_por_ID INTEGER,
TipoOrden NVARCHAR(50),
Organizacion NVARCHAR(100),
FechaCreacion DATE,
FechaAceptacion DATE,
FechaLimitePago DATE,
FechaEstimadaEntrega DATE,
FechaEntrega DATE,
EntregaATiempo BOOLEAN,
Estado NVARCHAR(50),
Total DECIMAL(10,2),
MetodoPago_ID INTEGER,
DescuentoAplicado DECIMAL(5,2),
TiempoReposicion DECIMAL(5,2),
TiempoEntrega DECIMAL(5,2),
FOREIGN KEY (Creado_por_ID) REFERENCES Usuario2(Usuario_ID),
FOREIGN KEY (Modificado_por_ID) REFERENCES Usuario2(Usuario_ID),
FOREIGN KEY (MetodoPago_ID) REFERENCES MetodoPago2(MetodoPago_ID)
);
-- 1.9 Tabla de OrdenesProductos
CREATE TABLE OrdenesProductos2 (
OrdenesProductos_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY
KEY,
Orden_ID INTEGER,
Inventario_ID INTEGER,
Cantidad INTEGER,
PrecioUnitario DECIMAL(10,2),
FOREIGN KEY (Orden_ID) REFERENCES Ordenes2(Orden_ID),
FOREIGN KEY (Inventario_ID) REFERENCES Inventario2(Inventario_ID)
);
-- 1.10 Tabla de Comentarios de Órdenes
CREATE TABLE ComentariosOrdenes2 (
Comentario_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Orden_ID INTEGER,
Creado_por_ID INTEGER,
Comentario NCLOB,
FechaCreado TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
FOREIGN KEY (Orden_ID) REFERENCES Ordenes2(Orden_ID),
FOREIGN KEY (Creado_por_ID) REFERENCES Usuario2(Usuario_ID)
);
-- 1.11 Tabla de Pagos por Orden
CREATE TABLE PagoOrden2 (
Pago_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Orden_ID INTEGER,
MetodoPago_ID INTEGER,
EstadoPago NVARCHAR(50),
ComentarioPago NCLOB,
FechaPago DATE,
DescuentoAplicado DECIMAL(5,2),
FOREIGN KEY (Orden_ID) REFERENCES Ordenes2(Orden_ID),
FOREIGN KEY (MetodoPago_ID) REFERENCES MetodoPago2(MetodoPago_ID)
);
-- 1.12 Tabla de Historial de Productos
CREATE TABLE HistorialProductos2 (
Historial_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Inventario_ID INTEGER,
Location_ID INTEGER,
Anio INTEGER,
Mes INTEGER,
Importacion INTEGER,
Exportacion INTEGER,
StockStart INTEGER,
StockEnd INTEGER,
FOREIGN KEY (Inventario_ID) REFERENCES Inventario2(Inventario_ID),
FOREIGN KEY (Location_ID) REFERENCES Location2(Location_ID)
);
-- 1.13 Tabla de Alertas
CREATE TABLE Alertas2 (
Alerta_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Descripcion NCLOB,
FechaCreacion DATE,
OrdenesProductos_ID INTEGER,
Location_ID INTEGER,
FOREIGN KEY (OrdenesProductos_ID) REFERENCES
OrdenesProductos2(OrdenesProductos_ID),
FOREIGN KEY (Location_ID) REFERENCES Location2(Location_ID)
);
-- 1.14 Tabla Bitácora Maestra
CREATE TABLE Bitacora_Maestra2 (
Bitacora_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
Nombre NVARCHAR(100)
);
-- 1.15 Tabla Bitácora General
CREATE TABLE Bitacora_General2 (
General_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
MaestraID INTEGER,
CampoID INTEGER,
Nombre NVARCHAR(100),
Descripcion NCLOB,
FOREIGN KEY (MaestraID) REFERENCES Bitacora_Maestra2(Bitacora_ID)
);
-- ========================================
-- 2. STORE PROCEDURES
-- ========================================
-- 2.1 ObtenerPedidosPorOrganizacion
CREATE OR REPLACE PROCEDURE ObtenerPedidosPorOrganizacion (
IN organizacion NVARCHAR(100)
)
LANGUAGE SQLSCRIPT SQL SECURITY INVOKER
AS
BEGIN
SELECT
u.Correo AS Usuario,
o.Organizacion,
a.Nombre AS Producto,
o.FechaCreacion AS FechaPedido,
o.FechaEntrega,
op.Cantidad,
op.PrecioUnitario,
(op.Cantidad * op.PrecioUnitario) AS TotalLinea
FROM Usuario2 u
JOIN Ordenes2 o ON u.Usuario_ID = o.Creado_por_ID
JOIN OrdenesProductos2 op ON o.Orden_ID = op.Orden_ID
JOIN Inventario2 i ON op.Inventario_ID = i.Inventario_ID
JOIN Articulo2 a ON i.Articulo_ID = a.Articulo_ID
WHERE o.Organizacion = :organizacion
ORDER BY o.FechaCreacion DESC;
END;
-- 2.2 ActualizarMetricasOrganizacion
CREATE OR REPLACE PROCEDURE ActualizarMetricasOrganizacion()
LANGUAGE SQLSCRIPT
AS
BEGIN
MERGE INTO HistorialProductos2 target
USING (
SELECT
u.Location_ID,
op.Inventario_ID,
COUNT(op.OrdenesProductos_ID) AS Importacion,
0 AS Exportacion,
0 AS StockStart,
i.StockActual AS StockEnd
FROM Ordenes2 o
JOIN Usuario2 u ON o.Creado_por_ID = u.Usuario_ID
JOIN OrdenesProductos2 op ON o.Orden_ID = op.Orden_ID
JOIN Inventario2 i ON op.Inventario_ID = i.Inventario_ID
WHERE o.FechaCreacion >= ADD_MONTHS(CURRENT_DATE, -1)
GROUP BY u.Location_ID, op.Inventario_ID, i.StockActual
) source
ON (target.Location_ID = source.Location_ID AND target.Inventario_ID =
source.Inventario_ID AND target.Mes = MONTH(CURRENT_DATE) AND target.Anio =
YEAR(CURRENT_DATE))
WHEN MATCHED THEN
UPDATE SET
target.Importacion = source.Importacion,
target.Exportacion = source.Exportacion,
target.StockStart = target.StockStart,
target.StockEnd = source.StockEnd;
END;
-- ========================================
-- 3. TRIGGERS Y ALERTAS
-- ========================================
-- 3.1 Actualizar métricas de usuario
CREATE OR REPLACE TRIGGER trg_actualizar_metricas_usuario
AFTER INSERT OR UPDATE ON Ordenes2
REFERENCING NEW ROW AS new_row
FOR EACH ROW
BEGIN
UPDATE Usuario2
SET FechaEmpiezo = (
SELECT COALESCE(AVG(DAYS_BETWEEN(FechaEntrega, FechaCreacion)), 0)
FROM Ordenes2
WHERE Creado_por_ID = new_row.Creado_por_ID
)
WHERE Usuario_ID = new_row.Creado_por_ID;
END;
-- 3.2 Alerta retraso
CREATE OR REPLACE TRIGGER trg_alerta_retraso_entrega
AFTER UPDATE ON Ordenes2
REFERENCING NEW ROW AS new_row
FOR EACH ROW
BEGIN
IF new_row.FechaEntrega IS NULL AND new_row.FechaEstimadaEntrega <
CURRENT_DATE THEN
INSERT INTO Alertas2 (Descripcion, FechaCreacion, OrdenesProductos_ID,
Location_ID)
SELECT
'¡Alerta! Orden #' || new_row.Orden_ID || ' retrasada.',
CURRENT_TIMESTAMP,
op.OrdenesProductos_ID,
u.Location_ID
FROM OrdenesProductos2 op
JOIN Usuario2 u ON u.Usuario_ID = new_row.Creado_por_ID
WHERE op.Orden_ID = new_row.Orden_ID;
END IF;
END;
-- 3.3 Alerta orden aceptada
CREATE OR REPLACE TRIGGER trg_alerta_orden_aceptada
AFTER UPDATE ON Ordenes2
REFERENCING NEW ROW AS new_row
FOR EACH ROW
BEGIN
IF new_row.FechaAceptacion IS NOT NULL AND new_row.Estado = 'Aceptada' THEN
INSERT INTO Alertas2 (Descripcion, FechaCreacion, OrdenesProductos_ID,
Location_ID)
SELECT
'¡Orden #' || new_row.Orden_ID || ' aceptada!',
CURRENT_TIMESTAMP,
op.OrdenesProductos_ID,
u.Location_ID
FROM OrdenesProductos2 op
JOIN Usuario2 u ON u.Usuario_ID = new_row.Creado_por_ID
WHERE op.Orden_ID = new_row.Orden_ID;
END IF;
END;
-- 3.4 Inventario bajo
CREATE OR REPLACE TRIGGER trg_alerta_inventario_bajo
AFTER INSERT OR UPDATE ON Inventario2
REFERENCING NEW ROW AS inv
FOR EACH ROW
BEGIN
IF inv.StockActual < inv.StockMinimo THEN
INSERT INTO Alertas2 (Descripcion, FechaCreacion, Location_ID)
VALUES (
'¡Inventario bajo ArtID ' || inv.Articulo_ID || ' en LocID ' || inv.Location_ID || '!',
CURRENT_TIMESTAMP,
inv.Location_ID
);
END IF;
END;
-- 3.5 Llegada de inventario
CREATE OR REPLACE TRIGGER trg_alerta_importacion
AFTER UPDATE ON Inventario2
REFERENCING NEW ROW AS inv
FOR EACH ROW
BEGIN
IF inv.Importacion > 0 THEN
INSERT INTO Alertas2 (Descripcion, FechaCreacion, Location_ID)
VALUES (
'¡' || inv.Importacion || ' unidades importadas ArtID ' || inv.Articulo_ID || '!',
CURRENT_TIMESTAMP,
inv.Location_ID
);
END IF;
END;
-- 3.6 Salida de inventario
CREATE OR REPLACE TRIGGER trg_alerta_exportacion
AFTER UPDATE ON Inventario2
REFERENCING NEW ROW AS inv
FOR EACH ROW
BEGIN
IF inv.Exportacion > 0 THEN
INSERT INTO Alertas2 (Descripcion, FechaCreacion, Location_ID)
VALUES (
'¡' || inv.Exportacion || ' unidades exportadas ArtID ' || inv.Articulo_ID || '!',
CURRENT_TIMESTAMP,
inv.Location_ID
);
END IF;
END;
-- ========================================
-- 4. PREDICTIVE ANALYSIS LIBRARY WRAPPERS
-- ========================================
CREATE OR REPLACE PROCEDURE Run_DemandaPronostico()
LANGUAGE SQLSCRIPT
AS
BEGIN
-- 1) Datos históricos para entrenar (igual que antes)
DECLARE lt_input TABLE(
Inventario_ID INT,
Demanda DOUBLE,
StockActual DOUBLE,
Mes INT
);
lt_input =
SELECT h.Inventario_ID,
h.Exportacion AS Demanda,
i.StockActual,
MONTH(h.Mes || '-01') AS Mes
FROM HistorialProductos2 h
JOIN Inventario2 i ON h.Inventario_ID = i.Inventario_ID
WHERE h.Anio >= YEAR(CURRENT_DATE) - 1;
-- 2) Ajuste de regresión lineal
DECLARE lt_coeff TABLE(FEATURE NVARCHAR(50), COEFF DOUBLE);
CALL "PAL"."PAL_LINEAR_REG_GET_COEFF"(:lt_input, 'Demanda', lt_coeff);
-- 3) Generar pronóstico diario y calcular alertas
DECLARE lt_forecast TABLE(
Inventario_ID INT,
DemandaPronosticada DOUBLE,
StockActual DOUBLE,
StockRecomendado INT,
Location_ID INT
);
lt_forecast =
SELECT
inv.Inventario_ID,
-- Pronóstico para mañana
lt.COEFF[1]
+ inv.StockActual * lt.COEFF[2]
+ MONTH(ADD_DAYS(CURRENT_DATE,1)) * lt.COEFF[3]
AS DemandaPronosticada,
inv.StockActual,
inv.StockRecomendado,
inv.Location_ID
FROM Inventario2 inv
CROSS JOIN (SELECT * FROM lt_coeff) lt;
-- 4) Insertar alertas de reabastecimiento
FOR cur AS SELECT * FROM :lt_forecast DO
DECLARE dias DOUBLE = cur.StockActual / NULLIF(cur.DemandaPronosticada,0);
DECLARE qty_reponer INT = GREATEST(cur.StockRecomendado - cur.StockActual,
CEIL(cur.DemandaPronosticada * 3));
-- Si va a agotarse en menos de, digamos, 7 días, alertamos
IF dias < 7 THEN
INSERT INTO Alertas2 (Descripcion, FechaCreacion, OrdenesProductos_ID,
Location_ID)
VALUES (
'Artículo ' || cur.Inventario_ID ||
' en ubic. ' || cur.Location_ID ||
' se agotará en ' || ROUND(dias,1) || ' días. Pedir ' || qty_reponer || ' unidades.',
CURRENT_TIMESTAMP,
NULL,
cur.Location_ID
);
END IF;
END FOR;
END;
-- ========================================
-- 5. SCHEDULER
-- ========================================
-- Scheduler para lanzar el wrapper cada noche a las 02:00
CREATE SCHEDULER JOB Job_PronosticoReabastecimiento
ACTION 'CALL Run_DemandaPronostico()'
SCHEDULE 'FREQ=DAILY;BYHOUR=2;BYMINUTE=0;BYSECOND=0'
COMMENT 'Pronóstico y alertas de reabastecimiento diario a las 02:00';